# -*- coding: utf-8 -*-
# ========================================
# 1. 문제 유형 분석
# ========================================
# 키워드: 마감일, 점수 최대화
# 문제 유형: 그리디 + 정렬 문제
#
# 직관적 접근법:
# - 점수가 높은 과제부터 처리하기
# - 각 과제를 가능한 한 마감일에 가깝게 배치
# - 마감일이 겹치면 앞으로 당기기
# - 1일까지 당겨도 자리가 없으면 포기
#
# 핵심 아이디어:
# 1. 점수가 높은 순으로 정렬
# 2. 각 과제를 마감일부터 시작해서 1일까지 역순으로 확인
# 3. 비어있는 날을 찾아서 과제 배치
# 4. 배치 성공하면 점수 추가
#
# 왜 이게 최적인가?
# - 그리디: 점수가 높은 것을 우선 선택
# - 마감일에 가깝게 배치하면 나중에 다른 과제를 배치할 여유 생김
#
# 예시:
# 과제 [(마감일, 점수)]: [(4, 60), (2, 50), (4, 40), (3, 30)]
# 점수순 정렬: [(4, 60), (2, 50), (4, 40), (3, 30)]
# - (4, 60): 4일에 배치, 점수 60
# - (2, 50): 2일에 배치, 점수 50
# - (4, 40): 4일 차있음, 3일에 배치, 점수 40
# - (3, 30): 3일 차있음, 1일에 배치, 점수 30
# 총점: 180
#
# ========================================
# 2. 코드 분석
# ========================================

import sys
input = sys.stdin.readline

N = int(input())  # 과제 개수

assignments = []
for _ in range(N):
    d, w = map(int, input().split())  # d: 마감일, w: 점수
    assignments.append((d, w))

# 점수 내림차순으로 정렬 (점수가 높은 것부터)
# 예: [(4,60), (2,50), (4,40)] 을 그대로 유지 (이미 점수순)
assignments.sort(key=lambda x: -x[1])

# 각 날짜에 과제가 배치되었는지 확인
# 최대 마감일을 찾아서 그만큼의 배열 생성
# 예: 마감일이 1~1000이면 1001 크기 (0번 인덱스는 안 씀)
max_day = max(d for d, w in assignments) if assignments else 0
schedule = [False] * (max_day + 1)  # False: 비어있음, True: 차있음

total_score = 0  # 총 점수

# 점수가 높은 과제부터 처리
for deadline, score in assignments:
    # 마감일부터 1일까지 역순으로 확인
    # 예: deadline=4면 4, 3, 2, 1 순서로 확인
    for day in range(deadline, 0, -1):  # range(4, 0, -1) = [4, 3, 2, 1]
        # 해당 날짜가 비어있으면 과제 배치
        if not schedule[day]:
            schedule[day] = True  # 이 날짜에 과제 배치
            total_score += score   # 점수 추가
            break  # 배치 완료했으므로 다음 과제로
        # 이미 차있으면 다음 날짜(하루 앞)로 이동

    # for문이 break 없이 끝나면 = 배치 못 함 = 포기

print(total_score)

# ========================================
# 3. Q&A
# ========================================
# Q1: 왜 점수 내림차순으로 정렬하나요?
# A: 그리디 알고리즘의 핵심입니다.
#    점수가 높은 과제를 우선 선택해야 총점이 최대가 됩니다.
#    낮은 점수의 과제는 자리가 없으면 포기해도 손해가 적습니다.
#
# Q2: 왜 마감일부터 역순으로 확인하나요?
# A: 마감일에 가깝게 배치해야 다른 과제를 배치할 여유가 생깁니다.
#    예: 마감일이 4일인 과제를 1일에 배치하면
#        2~4일이 낭비되지만, 4일에 배치하면 1~3일을 활용 가능!
#
# Q3: range(deadline, 0, -1)은 무슨 의미인가요?
# A: deadline부터 1까지 -1씩 감소하는 범위입니다.
#    예: range(4, 0, -1) = [4, 3, 2, 1]
#    0은 포함되지 않습니다 (날짜는 1일부터 시작)
#
# Q4: schedule 배열은 왜 필요한가요?
# A: 각 날짜에 이미 과제가 배치되었는지 빠르게 확인하기 위해서입니다.
#    schedule[day] = True면 이미 차있음
#    schedule[day] = False면 비어있음
#
# Q5: 구체적인 예시를 더 보여주세요.
# A: 과제: [(4,60), (2,50), (4,40), (3,30), (1,20)]
#    점수순 정렬: [(4,60), (2,50), (4,40), (3,30), (1,20)]
#
#    (4,60): 4일 비어있음, 4일에 배치 [_, _, _, O] +60
#    (2,50): 2일 비어있음, 2일에 배치 [_, O, _, O] +50
#    (4,40): 4일 차있음, 3일 시도, 3일에 배치 [_, O, O, O] +40
#    (3,30): 3일 차있음, 2일 차있음, 1일에 배치 [O, O, O, O] +30
#    (1,20): 1~1일 모두 차있음, 포기 +0
#    총점: 180
#
# Q6: 시간 복잡도는?
# A: - 정렬: O(N log N)
#    - 각 과제마다 최대 max_day번 확인: O(N * max_day)
#    - 전체: O(N log N + N * max_day)
#    - N, max_day가 최대 1000이므로 충분히 빠름
#
# Q7: 더 효율적인 방법은?
# A: Union-Find(Disjoint Set)를 사용하면 O(N log N)에 풀 수 있지만,
#    이 문제는 제한이 작아서 현재 방법으로도 충분합니다.
#    (초보자에게는 현재 방법이 더 이해하기 쉬움!)
#
# Q8: break의 역할은?
# A: 과제를 배치하면 더 이상 다른 날짜를 확인할 필요가 없으므로
#    for문을 빠져나와 다음 과제로 넘어갑니다.
#    break가 실행되지 않으면 = 모든 날짜가 차있음 = 과제 포기
#
# ========================================
# 학습 포인트
# ========================================
# 1. 그리디 알고리즘: 점수 높은 것부터 선택
# 2. 역순 탐색: 마감일부터 1일까지
# 3. 배열로 상태 관리: schedule[day]
# 4. 정렬의 중요성: key=lambda 사용
# 5. break로 조기 종료
