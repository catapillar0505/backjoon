# -*- coding: utf-8 -*-
# ========================================
# 1. 문제 유형 분석
# ========================================
# 키워드: 최대 3개, 조합, 합이 C
# 문제 유형: 투 포인터 + 이진 탐색
#
# 핵심 통찰:
# - 1개: 배열에 C가 있는지 확인 (in 연산)
# - 2개: 투 포인터로 두 수의 합이 C인지 확인
# - 3개: 투 포인터로 두 수를 선택한 후,
#        이진 탐색으로 나머지 하나(C - 두 수의 합)를 찾기!
#
# 왜 이진 탐색이 필요한가?
# - 3개를 for문으로 찾으면 O(N^2)로 시간 초과
# - 투 포인터(2개) + 이진 탐색(1개)으로 O(N log N)에 해결
#
# 시간 복잡도:
# - 정렬: O(N log N)
# - 1개 확인: O(N) (in 연산)
# - 2개 + 3개 확인: O(N log N) (투 포인터 + 이진 탐색)
# - 전체: O(N log N)
#
# ========================================
# 2. 코드 분석
# ========================================

import sys
input = sys.stdin.readline

n, c = map(int, input().split())  # n: 물건 개수, c: 목표 무게
data = list(map(int, input().split()))  # 물건들의 무게

# 정렬: 투 포인터와 이진 탐색을 위해 필수!
# 예: [5, 2, 3, 1, 4] 를 [1, 2, 3, 4, 5] 로 정렬
data.sort()

def binary_search(left, right, diff):
    """
    이진 탐색: data[left]부터 data[right]까지 범위에서
    diff 값이 있는지 빠르게 찾기

    예: [1, 2, 3, 4, 5]에서 3 찾기
    - 중간(mid=2) 확인: data[2]=3 찾음!

    왜 이진 탐색?
    - 일반 탐색: O(N) 시간
    - 이진 탐색: O(log N) 시간 (훨씬 빠름!)
    """
    while left <= right:
        mid = (left + right) // 2  # 중간 위치

        if data[mid] == diff:  # 찾았다!
            return 1
        elif data[mid] > diff:  # 찾는 값이 더 작음 -> data[mid]도 작아져야함
            right = mid - 1
        else:  # data[mid] < diff: 찾는 값이 오른쪽에 있음
            left = mid + 1

    return 0  # 못 찾음

def check(n, c):
    """
    1개, 2개, 3개 조합으로 c를 만들 수 있는지 확인
    """
    # --------------------------------
    # Case 1: 물건 1개로 c 만들기
    # --------------------------------
    # 예: c=5이고 data=[1,2,3,4,5]면 5가 있으므로 가능!
    if c in data:
        return 1

    # --------------------------------
    # Case 2와 3: 투 포인터로 확인
    # --------------------------------
    # i는 왼쪽(작은 값), j는 오른쪽(큰 값)
    i, j = 0, n - 1

    while i < j:  # 두 포인터가 만나기 전까지
        total = data[i] + data[j]  # 두 물건의 합

        if total > c:
            # 합이 너무 크면 j를 왼쪽으로 (더 작은 값 필요)
            j -= 1

        elif total == c:
            # --------------------------------
            # Case 2: 물건 2개로 c 만들기 성공!
            # --------------------------------
            # 예: data[i]=2, data[j]=3, c=5 이면 2+3=5
            return True

        else:  # total < c
            # --------------------------------
            # Case 3: 물건 3개로 c 만들기 시도
            # --------------------------------
            # total < c 이므로 하나 더 필요함
            # diff = c - total (필요한 나머지 값)
            # 예: c=10, data[i]=2, data[j]=3, total=5
            #     diff = 10-5 = 5 (5를 찾으면 됨!)

            diff = c - total

            # 중요: diff가 이미 선택한 data[i]나 data[j]와 같으면 안됨
            # (같은 물건을 중복 선택할 수 없음!)
            # 예: data=[1,2,5], c=10, i=0, j=2
            #     total=1+5=6, diff=4
            #     4가 배열에 없으므로 불가능

            # diff가 data[i], data[j]와 다르고
            # i와 j 사이에 diff가 있는지 이진 탐색으로 확인
            if data[i] != diff and data[j] != diff and binary_search(i, j, diff):
                return True

            # 합이 작으므로 i를 오른쪽으로 (더 큰 값 필요)
            i += 1

    return False  # 모든 경우를 확인했지만 못 찾음

# 결과 출력
if check(n, c):
    print(1)
else:
    print(0)

# ========================================
# 3. Q&A
# ========================================
# Q1: 왜 이진 탐색이 필요한가요?
# A: 3개 조합을 for문 3개로 찾으면 O(N^3)로 시간 초과입니다.
#    투 포인터(2개) + 이진 탐색(1개)로 O(N log N)에 해결합니다.
#    예: N=100,000이면
#        O(N^3) = 10^15 (시간 초과!)
#        O(N log N) = 10^6 (통과!)
#
# Q2: binary_search(i, j, diff)는 무엇을 찾나요?
# A: data[i]와 data[j] 사이에 diff 값이 있는지 찾습니다.
#    예: data=[1,2,3,4,5], i=0, j=4, diff=3
#        data[1]부터 data[3]까지 범위에서 3을 찾음
#        (data[0]과 data[4]는 이미 선택했으므로 제외!)
#
# Q3: data[i] != diff and data[j] != diff 조건은 왜 필요한가요?
# A: 같은 물건을 중복 선택할 수 없기 때문입니다.
#    예: data=[1,2,3], c=6, i=0, j=2
#        total=1+3=4, diff=6-4=2
#        data[1]=2 이므로 가능! (1+2+3=6)
#    반례: data=[2,4], c=8, i=0, j=1
#        total=2+4=6, diff=8-6=2
#        diff=2=data[i] 이므로 불가능!
#        (2를 두 번 사용할 수 없음)
#
# Q4: 왜 투 포인터에서 total > c이면 j를 줄이나요?
# A: 배열이 정렬되어 있으므로:
#    - j를 줄이면 data[j]가 작아짐 (합이 작아짐)
#    - i를 늘리면 data[i]가 커짐 (합이 커짐)
#    total > c이면 합을 줄여야 하므로 j를 줄입니다.
#
# Q5: 이진 탐색의 시간 복잡도는?
# A: O(log N)입니다.
#    - 매번 탐색 범위가 절반으로 줄어듭니다.
#    - 예: 1000개 -> 500 -> 250 -> 125 -> ... (약 10번)
#    - 일반 탐색은 O(N)이므로 1000번 비교
#
# Q6: 구체적인 예시를 보여주세요.
# A: data=[1,2,3,4,5], c=10
#
#    Case 1: 10 in data? 아니요
#
#    Case 2와 3 (투 포인터):
#    i=0, j=4: 1+5=6 < 10
#              diff=10-6=4
#              4는 1, 5가 아니고, binary_search(0,4,4)=1
#              1+4+5=10 성공!
#
# Q7: 왜 원래 코드는 시간 초과가 났나요?
# A: 3개 조합을 for문으로 찾으면 O(N^2)입니다.
#    N=100,000이면 10^10번 연산으로 시간 초과!
#    이진 탐색을 사용하면 O(N log N)으로 해결됩니다.
#
# Q8: binary_search(i, j, diff)에서 범위가 i~j인 이유는?
# A: data[i]와 data[j]는 이미 선택했으므로 제외하고,
#    그 사이에서만 세 번째 물건을 찾아야 합니다.
#    만약 전체 범위를 탐색하면 중복 선택이 발생합니다.
#
# ========================================
# 학습 포인트
# ========================================
# 1. 이진 탐색: 정렬된 배열에서 O(log N) 탐색
# 2. 투 포인터 + 이진 탐색 조합
# 3. 시간 복잡도 최적화: O(N^2) -> O(N log N)
# 4. 중복 선택 방지: 조건문으로 같은 물건 제외
# 5. 정렬의 중요성: 투 포인터와 이진 탐색의 전제
