# -*- coding: utf-8 -*-
# ========================================
# 1. 문제 유형 분석
# ========================================
# 키워드: 최대 3개, 조합, 합이 C
# 문제 유형: 조합 + 정렬 + 투 포인터
#
# 직관적 접근법:
# - 물건을 1개, 2개, 3개 선택해서 합이 C가 되는지 확인
# - 1개: 그냥 C와 같은 물건이 있는지 확인 (해시/집합)
# - 2개: 투 포인터로 O(N)에 찾기
# - 3개: 하나 고정하고 나머지 2개를 투 포인터로 찾기
#
# 왜 정렬?
# - 투 포인터 알고리즘을 사용하려면 정렬이 필수!
# - 정렬하면 양 끝에서 시작해서 합을 조절할 수 있음
#
# 시간 복잡도:
# - 1개: O(N) (집합 검색)
# - 2개: O(N) (투 포인터)
# - 3개: O(N^2) (N개를 고정하고 각각 O(N) 투 포인터)
# - 전체: O(N^2)
#
# ========================================
# 2. 코드 분석
# ========================================

import sys
input = sys.stdin.readline

N, C = map(int, input().split())  # N: 물건 개수, C: 목표 무게
weights = list(map(int, input().split()))  # 물건들의 무게

# 정렬: 투 포인터 사용을 위해 필수!
# 예: [5, 2, 3, 1, 4] 를 [1, 2, 3, 4, 5] 로 정렬
weights.sort()

# 빠른 검색을 위해 집합(set)으로 변환
# 예: weights가 [1, 2, 3]이면 weight_set = {1, 2, 3}
# "3이 있나요?" O(1)에 확인 가능! (리스트는 O(N))
weight_set = set(weights)

# --------------------------------
# Case 1: 물건 1개로 C 만들기
# --------------------------------
# C와 같은 무게의 물건이 있는지 확인
# 예: C=5이고 weights=[1,2,3,4,5]면 5가 있으므로 가능!
if C in weight_set:
    print(1)
    exit()  # 답을 찾았으므로 프로그램 종료

# --------------------------------
# Case 2: 물건 2개로 C 만들기 (투 포인터)
# --------------------------------
# 투 포인터: 양쪽 끝에서 시작해서 중앙으로 이동
# left는 작은 쪽, right는 큰 쪽
left = 0
right = N - 1

while left < right:  # 두 포인터가 만나기 전까지
    total = weights[left] + weights[right]  # 두 물건의 합

    if total == C:  # 딱 맞으면 성공!
        print(1)
        exit()
    elif total < C:  # 합이 너무 작으면 left를 오른쪽으로 (더 큰 값 필요)
        left += 1
    else:  # total > C: 합이 너무 크면 right를 왼쪽으로 (더 작은 값 필요)
        right -= 1

# --------------------------------
# Case 3: 물건 3개로 C 만들기
# --------------------------------
# 전략: 하나를 고정하고 나머지 2개를 투 포인터로 찾기
# 예: [1, 2, 3, 4, 5], C=10
#     i=0 (1 고정) 나머지에서 9 찾기 (4+5=9) 1+4+5=10 성공!

for i in range(N):  # i번째 물건을 첫 번째로 선택
    target = C - weights[i]  # 나머지 두 물건의 합 목표
    # 예: C=10, weights[i]=1 이면 target=9

    # 투 포인터로 나머지 부분에서 target 찾기
    # left는 i 다음부터, right는 끝부터
    left = i + 1
    right = N - 1

    while left < right:
        total = weights[left] + weights[right]

        if total == target:  # 나머지 2개의 합이 target과 같으면 성공!
            # weights[i] + weights[left] + weights[right] = C
            print(1)
            exit()
        elif total < target:
            left += 1
        else:
            right -= 1

# 모든 경우를 다 확인했는데도 못 찾았으면 실패
print(0)

# ========================================
# 3. Q&A
# ========================================
# Q1: 투 포인터가 뭔가요?
# A: 정렬된 배열에서 두 개의 포인터를 양 끝에서 시작해
#    조건에 따라 이동시키며 원하는 값을 찾는 기법입니다.
#    합이 작으면 왼쪽 포인터를 오른쪽으로 (더 큰 값)
#    합이 크면 오른쪽 포인터를 왼쪽으로 (더 작은 값)
#
# Q2: 왜 set을 사용하나요?
# A: 리스트에서 특정 값을 찾으려면 O(N) 시간이 걸리지만,
#    set(집합)은 해시를 사용해서 O(1)에 찾을 수 있습니다.
#    예: 5 in [1,2,3,4,5] 는 5번 비교
#        5 in {1,2,3,4,5} 는 1번 비교
#
# Q3: exit()는 무엇인가요?
# A: 프로그램을 즉시 종료합니다.
#    답을 찾으면 더 이상 확인할 필요 없으므로 바로 끝냅니다.
#
# Q4: 왜 3개 조합에서 for문을 사용하나요?
# A: 첫 번째 물건을 하나씩 고정한 후,
#    나머지 2개를 투 포인터로 찾는 것이 효율적입니다.
#    3중 for문으로 모든 조합을 확인하면 O(N^3)이지만,
#    이 방법은 O(N^2)로 더 빠릅니다.
#
# Q5: left < right 조건은 왜 필요한가요?
# A: 같은 물건을 중복 선택할 수 없기 때문입니다.
#    left와 right가 같으면 같은 물건을 두 번 선택하는 것이므로
#    조건에 위배됩니다.
#
# Q6: 구체적인 투 포인터 예시를 보여주세요.
# A: [1, 2, 3, 4, 5]에서 합이 7인 두 수 찾기:
#    초기: left=0(1), right=4(5) 1+5=6 < 7 left++
#    다음: left=1(2), right=4(5) 2+5=7 = 7 찾음!
#
# Q7: 왜 정렬이 필수인가요?
# A: 투 포인터는 "작은 쪽"과 "큰 쪽"을 명확히 구분해야 합니다.
#    정렬되지 않으면 합의 증감을 예측할 수 없어서
#    포인터를 어느 방향으로 움직여야 할지 알 수 없습니다.
#
# ========================================
# 학습 포인트
# ========================================
# 1. 투 포인터 알고리즘: 정렬 후 양 끝에서 시작
# 2. set 자료구조: O(1) 검색 시간
# 3. 경우의 수 나누기: 1개, 2개, 3개
# 4. 시간 복잡도 최적화: O(N^3) 에서 O(N^2) 으로
# 5. exit()로 조기 종료
