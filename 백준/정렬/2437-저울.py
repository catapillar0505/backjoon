# -*- coding: utf-8 -*-
# ========================================
# 1. 문제 유형 분석
# ========================================
# 키워드: 측정할 수 없는 최솟값
# 문제 유형: 그리디 + 정렬 문제
#
# 직관적 접근법:
# - 저울추로 측정 가능한 무게의 범위를 계속 확장해나가기
# - 작은 추부터 사용해서 "끊기지 않는 구간"을 만들기
# - 구간이 끊기는 순간이 답!
#
# 핵심 아이디어:
# - 현재까지 [1, acc]의 모든 무게를 만들 수 있다고 가정
# - 새로운 추 w를 추가할 때:
#   1) w <= acc+1 이면: [1, acc+w]까지 만들 수 있음 (구간 확장!)
#   2) w > acc+1 이면: acc+1을 만들 수 없음 (구간이 끊김!)
#
# 예시로 이해하기:
# 추가 [1, 2, 3, 7]이고 정렬된 상태라면:
# - 초기: acc = 0 (아무것도 없음)
# - 추 1: 1 <= 0+1(1) (OK) acc = 0+1 = 1 (1까지 가능)
# - 추 2: 2 <= 1+1(2) (OK) acc = 1+2 = 3 (3까지 가능: 1, 2, 3)
# - 추 3: 3 <= 3+1(4) (OK) acc = 3+3 = 6 (6까지 가능: 1~6)
# - 추 7: 7 > 6+1(7) (FAIL) 7을 만들 수 없음! 답: 7
#
# 왜 이게 맞나요?
# - [1, acc]를 만들 수 있으면 새 추 w로 [w, acc+w]도 만들 수 있음
# - 두 구간이 끊기지 않으려면 w <= acc+1이어야 함!
#
# ========================================
# 2. 코드 분석
# ========================================

import sys
input = sys.stdin.readline

N = int(input())  # 추의 개수
weights = list(map(int, input().split()))  # 추들의 무게

# 추를 오름차순으로 정렬
# 작은 추부터 사용해야 구간을 끊기지 않게 확장 가능
# 예: [7, 3, 1, 2] 를 [1, 2, 3, 7] 로 정렬
weights.sort()

# acc: 현재까지 만들 수 있는 최대 무게
# [1, acc]의 모든 무게를 만들 수 있다는 의미
acc = 0  # 초기값: 아무 추도 사용 안 함

# 추를 하나씩 확인
for w in weights:
    # 현재 추 w가 acc+1보다 크면?
    # acc+1을 만들 수 없으므로 종료!
    # 예: acc=6이고 w=8이면 7을 만들 수 없음
    if w > acc + 1:
        break  # 더 이상 확인할 필요 없음

    # w <= acc+1이면 구간을 확장할 수 있음
    # 새로운 범위: [1, acc+w]
    # 예: acc=3이고 w=2면 [1, 3] 에서 [1, 5]로 확장
    acc += w

# 루프를 모두 돌았거나 중간에 끊긴 경우
# acc+1이 만들 수 없는 최솟값
# 예: acc=6이면 7이 답
print(acc + 1)

# ========================================
# 3. Q&A
# ========================================
# Q1: 왜 정렬이 필요한가요?
# A: 작은 추부터 사용해야 "끊기지 않는 구간"을 만들 수 있습니다.
#    큰 추부터 사용하면 중간에 구멍이 생깁니다.
#    예: [7, 1]을 순서대로 사용하면:
#        7로는 [7,7]만 가능, 1을 추가해도 [1,1]과 [7,8]만 가능
#        중간에 2,3,4,5,6이 빠짐!
#
# Q2: acc의 의미를 더 자세히 설명해주세요.
# A: acc는 "현재까지 만들 수 있는 최대 무게"입니다.
#    더 정확히는 [1, acc] 범위의 모든 정수를 만들 수 있다는 의미입니다.
#    예: acc=5면 1, 2, 3, 4, 5를 모두 만들 수 있음
#
# Q3: w > acc+1일 때 왜 종료하나요?
# A: 현재 [1, acc]까지 만들 수 있는데, 다음 추가 acc+1보다 크면
#    acc+1을 만들 방법이 없습니다!
#    예: [1,3]까지 가능한데 다음 추가 5면 4를 못 만듦
#
# Q4: 구체적인 예시를 더 보여주세요.
# A: 추가 [1, 1, 2, 3, 6, 7, 30]인 경우:
#    acc=0, w=1: 1<=1 (OK) acc=1 (1 가능)
#    acc=1, w=1: 1<=2 (OK) acc=2 (1,2 가능)
#    acc=2, w=2: 2<=3 (OK) acc=4 (1,2,3,4 가능)
#    acc=4, w=3: 3<=5 (OK) acc=7 (1~7 가능)
#    acc=7, w=6: 6<=8 (OK) acc=13 (1~13 가능)
#    acc=13, w=7: 7<=14 (OK) acc=20 (1~20 가능)
#    acc=20, w=30: 30>21 (FAIL) 21이 답!
#
# Q5: 왜 acc += w로 업데이트하나요?
# A: [1, acc]를 만들 수 있고 새 추 w를 추가하면:
#    - 기존: 1, 2, ..., acc
#    - 새로 추가: w, w+1, w+2, ..., w+acc
#    - w <= acc+1이면 두 구간이 겹치거나 붙어있음
#    - 따라서 [1, acc+w]의 모든 값을 만들 수 있음!
#
# Q6: 시간 복잡도는?
# A: O(N log N) - 정렬이 가장 오래 걸립니다.
#    for문은 O(N)이므로 전체는 정렬이 지배합니다.
#
# Q7: 만약 모든 추를 다 사용해도 끊기지 않으면?
# A: 루프가 끝난 후 acc+1을 출력합니다.
#    예: [1, 2, 3]이면 acc=6 답은 7
#
# ========================================
# 학습 포인트
# ========================================
# 1. 그리디 알고리즘: 작은 것부터 사용해 구간 확장
# 2. 구간의 연속성: w <= acc+1 조건
# 3. 정렬의 중요성: 최적해를 위한 순서
# 4. 수학적 사고: 구간 확장의 원리
# 5. 조기 종료: break로 효율성 향상
