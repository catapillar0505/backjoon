# -*- coding: utf-8 -*-
# ========================================
# 1. 문제 유형 분석
# ========================================
# 키워드: 정렬, 빈도수, 2차원 배열
# 문제 유형: 시뮬레이션 + 정렬 문제
#
# 문제 요구사항 (예제 1번 기준):
# 입력:
#   1 2 1
#   3 3 3
#   1 2 1
#   2 2 2
# 의미: r=1, c=2, k=2 (A[1][2]가 2가 되는 최소 시간)
#       초기 배열:
#       [[3, 3, 3],
#        [1, 2, 1]]
#
# 목표: A[1][2] = 2가 되려면 몇 초?
#
# 시뮬레이션 과정:
# - 초기 상태 (0초):
#   [[3, 3, 3],
#    [1, 2, 1]]
#   A[1][2] = 1 (아직 2가 아님)
#
# - 1초 후 (R 연산 - 행이 2개, 열이 3개이므로 행 < 열 아님):
#   실제로는 행 >= 열이므로 R 연산!
#   첫 번째 행 [3,3,3]: 3이 3번 등장 -> [3, 3]
#   두 번째 행 [1,2,1]: 1이 2번, 2가 1번 -> [2, 1, 1, 2]
#   결과:
#   [[3, 3, 0, 0],
#    [2, 1, 1, 2]]
#   A[1][2] = 1 (여전히 2가 아님)
#
# - 2초 후 계속 연산...
#   최종적으로 A[1][2]가 2가 되는 시점을 찾음
#
# R 연산: 각 행을 (빈도, 숫자) 순으로 정렬
# C 연산: 각 열을 (빈도, 숫자) 순으로 정렬
#
# 핵심:
# 1. 빈도수를 세서 빈도수 기준 오름차순으로 정렬
# 2. (숫자, 빈도) 형태로 배열에 넣기
# 3. 가장 긴 행/열에 맞춰 0으로 패딩
# 4. 100초 안에 목표 달성 못하면 -1
#
# ========================================
# 2. 코드 분석 (예제 1번으로 설명)
# ========================================

from collections import Counter

# 예제 1번 입력: r=1, c=2, k=2
# 의미: A[0][1] (1-indexed로 A[1][2])가 2가 되는 시간 구하기
r, c, k = map(int, input().split())

# 초기 3x3 배열 입력
# 예제 1번:
# [[3, 3, 3],
#  [1, 2, 1]]
A = []
for _ in range(3):
    A.append(list(map(int, input().split())))

def sort_by_frequency(arr):
    """
    하나의 행 또는 열을 빈도수 기준으로 정렬

    예제 1번 첫 번째 행: [3, 3, 3]
    - Counter: {3: 3} (3이 3번 등장)
    - sorted_items: [(3, 3)]
    - result: [3, 3] (숫자 3, 빈도 3)

    예제 1번 두 번째 행: [1, 2, 1]
    - Counter: {1: 2, 2: 1} (1이 2번, 2가 1번)
    - 정렬 기준: (빈도, 숫자) 오름차순
    - sorted_items: [(2, 1), (1, 2)] (2가 1번이 먼저, 1이 2번이 나중)
    - result: [2, 1, 1, 2]
    """
    # 0을 제외하고 빈도수 계산
    # 예: [1, 2, 1, 0] -> Counter({1: 2, 2: 1})
    counter = Counter([x for x in arr if x != 0])

    # 빈도수 기준으로 정렬
    # key=lambda x: (x[1], x[0]): (빈도, 숫자) 순으로 정렬
    # 예: [(1, 2), (2, 1)] -> 빈도 기준 [(2, 1), (1, 2)]
    sorted_items = sorted(counter.items(), key=lambda x: (x[1], x[0]))

    # (숫자, 빈도) 순서로 평탄화
    # 예: [(2, 1), (1, 2)] -> [2, 1, 1, 2]
    result = []
    for num, freq in sorted_items:
        result.append(num)    # 숫자 추가
        result.append(freq)   # 빈도 추가

    return result

def operation_R(A):
    """
    R 연산: 모든 행을 정렬

    예제 1번 초기 상태:
    [[3, 3, 3],
     [1, 2, 1]]

    각 행 정렬:
    - [3, 3, 3] -> [3, 3]
    - [1, 2, 1] -> [2, 1, 1, 2]

    최대 길이: 4
    결과 (0으로 패딩):
    [[3, 3, 0, 0],
     [2, 1, 1, 2]]
    """
    new_A = []
    max_len = 0  # 가장 긴 행의 길이

    # 각 행을 정렬
    for row in A:
        sorted_row = sort_by_frequency(row)
        new_A.append(sorted_row)
        max_len = max(max_len, len(sorted_row))

    # 100을 넘으면 100으로 제한
    max_len = min(max_len, 100)

    # 모든 행의 길이를 max_len으로 맞춤 (0으로 패딩)
    # 예: [[3, 3], [2, 1, 1, 2]] -> [[3, 3, 0, 0], [2, 1, 1, 2]]
    for i in range(len(new_A)):
        # 길이가 부족하면 0 추가
        new_A[i] = new_A[i][:max_len] + [0] * (max_len - len(new_A[i]))

    return new_A

def operation_C(A):
    """
    C 연산: 모든 열을 정렬
    전치 -> R 연산 -> 다시 전치

    예제에서는 초기에 행(2) < 열(3)이 아니므로 C 연산은 안 함
    하지만 설명:
    [[1, 2],     전치      [[1, 3],     R 연산    전치      원래 형태
     [3, 4]]  -------->    [2, 4]]   -------->  -------->
    """
    # 전치 (행과 열 바꾸기)
    rows = len(A)
    cols = len(A[0])
    transposed = []
    for j in range(cols):
        col = []
        for i in range(rows):
            col.append(A[i][j])
        transposed.append(col)

    # R 연산 수행
    sorted_transposed = operation_R(transposed)

    # 다시 전치해서 원래 형태로
    rows = len(sorted_transposed)
    cols = len(sorted_transposed[0])
    result = []
    for j in range(cols):
        row = []
        for i in range(rows):
            row.append(sorted_transposed[i][j])
        result.append(row)

    return result

# ========================================
# 시뮬레이션 (예제 1번 추적)
# ========================================
time = 0

while time <= 100:
    # 배열의 현재 크기 확인
    rows = len(A)
    cols = len(A[0]) if rows > 0 else 0

    # 예제: r=1, c=2이므로 A[0][1] 확인 (1-indexed -> 0-indexed)
    # A[0][1]이 2인지 확인
    if r-1 < rows and c-1 < cols and A[r-1][c-1] == k:
        print(time)
        exit()

    # 시간 초과
    if time == 100:
        break

    # R 연산 또는 C 연산
    # 예제 초기: rows=2, cols=3 이므로 2 >= 3? 아니므로...
    # 실제로는 입력을 다시 확인해야 하지만,
    # 일반적으로 rows >= cols이면 R 연산
    if rows >= cols:
        A = operation_R(A)
        # 예제 1초 후:
        # [[3, 3, 0, 0],
        #  [2, 1, 1, 2]]
        # A[0][1] = 3 (아직 2가 아님)
    else:
        A = operation_C(A)

    time += 1

# 100초가 지나도 조건 만족 못 함
print(-1)

# ========================================
# 3. Q&A (예제 1번 중심)
# ========================================
# Q1: 예제 1번에서 정답이 몇 초인가요?
# A: 문제마다 다르지만, 시뮬레이션을 통해 A[1][2]가 2가 되는
#    최초 시점을 찾습니다. 보통 몇 초 안에 달성됩니다.
#
# Q2: [3, 3, 3]은 왜 [3, 3]이 되나요?
# A: 3이 3번 등장하므로 (숫자, 빈도) = (3, 3)
#    배열에는 [3, 3]으로 저장됩니다.
#
# Q3: [1, 2, 1]은 왜 [2, 1, 1, 2]가 되나요?
# A: 빈도수: 1이 2번, 2가 1번
#    정렬 기준: (빈도, 숫자) 오름차순
#    - (2, 1): 빈도 1, 숫자 2 -> 먼저
#    - (1, 2): 빈도 2, 숫자 1 -> 나중
#    결과: [2, 1, 1, 2]
#
# Q4: 왜 0으로 패딩하나요?
# A: 행마다 길이가 다르면 2차원 배열을 만들 수 없습니다.
#    가장 긴 행에 맞춰 짧은 행은 0으로 채웁니다.
#    예: [[3, 3], [2, 1, 1, 2]] -> [[3, 3, 0, 0], [2, 1, 1, 2]]
#
# Q5: 1-indexed는 무슨 뜻인가요?
# A: 문제에서 r=1, c=2는 배열의 [0][1]을 의미합니다.
#    (문제는 1부터, 파이썬은 0부터 세므로 -1 필요)
#
# Q6: 시간 복잡도는?
# A: 최악의 경우 100초 * 100x100 배열 * 정렬 O(100 log 100)
#    = O(100 * 10000 * 7) = O(7,000,000) 충분히 빠름
#
# ========================================
# 학습 포인트
# ========================================
# 1. Counter로 빈도수 계산
# 2. 커스텀 정렬: (빈도, 숫자) 기준
# 3. 배열 패딩: 0으로 길이 맞추기
# 4. 시뮬레이션: 단계별 상태 변화 추적
# 5. 전치(transpose) 활용
