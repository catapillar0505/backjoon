# -*- coding: utf-8 -*-
# ========================================
# 1. 문제 유형 분석
# ========================================
# 키워드: 인접한 통나무의 높이 차이, 최소화
# 문제 유형: 그리디 + 정렬 문제
#
# 직관적 접근법:
# - 통나무를 원형으로 배치할 때 인접한 통나무의 높이 차이를 최소화하려면?
# - 비슷한 높이의 통나무끼리 붙여야 함!
# - 정렬 후 작은 것과 큰 것을 양쪽에 번갈아 배치하면 됨
#
# 핵심 통찰:
# - 통나무를 오름차순 정렬하면, 최종 배치에서 인접한 통나무는
#   정렬된 배열에서 2칸 떨어진 통나무가 됨!
# - 예: [1, 2, 3, 4, 5] 정렬 후 배치 [1, 3, 5, 4, 2] (양쪽에서 번갈아)
#   인접: 1-3, 3-5, 5-4, 4-2, 2-1
# - 따라서 arr[i]와 arr[i-2]의 차이만 확인하면 됨!
#
# 왜 2칸 떨어진 원소끼리 비교?
# - 작은 것부터 양쪽에 번갈아 배치하면:
#   [1, 3, 5, 7, 9] 배치시: 1을 놓고, 3을 오른쪽, 5를 왼쪽, 7을 오른쪽...
#   결과: [5, 3, 1, 2, 4] 같은 형태 (중앙부터 양쪽으로)
# - 이때 인접한 것들은 원래 배열에서 2칸씩 떨어져 있음
#
# ========================================
# 2. 코드 분석
# ========================================

import sys
input = sys.stdin.readline

T = int(input())  # 테스트 케이스 개수

for _ in range(T):
    N = int(input())  # 통나무 개수
    logs = list(map(int, input().split()))  # 통나무 높이들

    # 통나무를 오름차순으로 정렬
    # 예: [1, 4, 3, 2, 5] 를 [1, 2, 3, 4, 5] 로 정렬
    logs.sort()

    # 최대 높이 차이를 저장할 변수
    max_diff = 0

    # 정렬된 배열에서 2칸 떨어진 원소끼리 비교
    # i=2부터 시작 (i-2가 0 이상이어야 하므로)
    # 예: [1, 2, 3, 4, 5]
    #      i=2: |3-1|=2, i=3: |4-2|=2, i=4: |5-3|=2
    for i in range(2, N):
        diff = abs(logs[i] - logs[i-2])  # 2칸 떨어진 원소의 차이
        max_diff = max(max_diff, diff)   # 최댓값 갱신

    print(max_diff)

# ========================================
# 3. Q&A
# ========================================
# Q1: 왜 2칸 떨어진 원소끼리 비교하나요?
# A: 통나무를 원형으로 최적 배치하면 정렬된 배열에서 2칸 떨어진
#    원소들이 실제로는 인접하게 됩니다.
#    배치 방식: [작은것들을 양쪽에 번갈아] 중앙부터 양쪽으로 퍼짐
#    예: [1,2,3,4,5] 를 [1,3,5,4,2] 또는 [5,3,1,2,4] 로 배치
#
# Q2: 왜 정렬이 필요한가요?
# A: 비슷한 높이의 통나무끼리 인접하게 만들기 위해서입니다.
#    정렬 없이 배치하면 높이 차이가 큰 통나무가 붙을 수 있습니다.
#
# Q3: 원형 배치는 어떻게 하나요?
# A: 실제로 배치할 필요는 없습니다!
#    정렬 후 2칸 간격으로 비교만 하면 최적 배치의 최대 차이를 알 수 있습니다.
#    이게 그리디의 핵심 - 최적 해의 성질을 이용해 간단히 풀기!
#
# Q4: 시간 복잡도는?
# A: O(N log N) - 정렬이 가장 오래 걸립니다.
#    비교는 O(N)이므로 전체는 정렬이 지배합니다.
#
# Q5: 구체적인 배치 예시를 보여줄 수 있나요?
# A: [1, 2, 3, 4, 5]를 배치한다면:
#    - 중앙에 1을 놓음: [_, _, 1, _, _]
#    - 오른쪽에 2: [_, _, 1, 2, _]
#    - 왼쪽에 3: [_, 3, 1, 2, _]
#    - 오른쪽에 4: [_, 3, 1, 2, 4]
#    - 왼쪽에 5: [5, 3, 1, 2, 4]
#    인접 쌍: (5,3)=2, (3,1)=2, (1,2)=1, (2,4)=2, (4,5)=1
#    최대 차이 = 2
#    이때 5-3=2는 배열에서 logs[4]-logs[2] (2칸 차이)
#
# Q6: 왜 abs()를 사용하나요?
# A: logs는 오름차순 정렬되어 있지만, 안전하게 절댓값을 취합니다.
#    실제로는 logs[i] > logs[i-2]이므로 abs() 없어도 되지만
#    명확성을 위해 사용합니다.
#
# ========================================
# 학습 포인트
# ========================================
# 1. 그리디 알고리즘: 정렬 후 최적의 성질을 이용
# 2. 원형 배치 문제의 특수성: 2칸 간격 비교
# 3. 실제 배치 대신 수학적 성질로 해결
# 4. 시간 복잡도 최적화: O(N^2) 에서 O(N log N) 으로
