# -*- coding: utf-8 -*-
# ========================================
# 1. 문제 유형 분석
# ========================================
# 키워드: "산술평균", "중앙값", "최빈값", "범위" -> 통계학 + 정렬 문제
#
# 직관적 접근법:
# - 산술평균: 모든 수를 더하고 개수로 나누면 됨 (초등학생도 아는 평균!)
# - 중앙값: 수를 쭉 정렬한 다음 가운데 값을 찾으면 됨 (홀수 개니까 딱 중간!)
# - 최빈값: 가장 많이 나온 숫자를 찾는데, 여러 개면 "두 번째로 작은 값" 주의!
# - 범위: 제일 큰 값 - 제일 작은 값
#
# 함정 주의:
# - 최빈값이 여러 개일 때 두 번째로 작은 값을 출력해야 함!
#   예: [1, 1, 2, 2, 3] -> 1과 2가 최빈값 -> 2를 출력
# - 평균은 "반올림"해야 함 (round 함수 사용)
# - 음수도 입력될 수 있음 (-4000 ~ 4000)
#
# ========================================
# 2. 코드 분석
# ========================================

import sys
from collections import Counter  # 빈도수를 세주는 도구 (딕셔너리보다 편리!)

input = sys.stdin.readline  # 빠른 입력을 위한 설정

# N개의 숫자를 입력받음
N = int(input())
numbers = []
for _ in range(N):
    numbers.append(int(input()))

# --------------------------------
# (1) 산술평균 구하기
# --------------------------------
# 예: [1, 2, 3, 4, 5] -> (1+2+3+4+5) / 5 = 3.0
average = round(sum(numbers) / N)  # sum()은 리스트의 모든 값을 더해줌
print(average)

# --------------------------------
# (2) 중앙값 구하기
# --------------------------------
# 예: [5, 1, 3, 2, 4] -> 정렬하면 [1, 2, 3, 4, 5] -> 중앙값은 3
numbers.sort()  # 오름차순으로 정렬 (작은 수부터 큰 수로)
median = numbers[N // 2]  # N이 5면 N//2는 2 -> numbers[2]가 중앙값
print(median)

# --------------------------------
# (3) 최빈값 구하기 (가장 많이 나온 수)
# --------------------------------
# 예: [1, 1, 2, 2, 3]
# Counter로 세면 {1: 2번, 2: 2번, 3: 1번}
# 최빈값은 1과 2 (둘 다 2번 등장)
# 이 중 두 번째로 작은 값은 2

counter = Counter(numbers)  # 각 숫자가 몇 번 나왔는지 세기
# Counter 결과 예: Counter({1: 2, 2: 2, 3: 1})

# most_common()은 빈도수가 높은 순으로 정렬해줌
# 예: [(1, 2), (2, 2), (3, 1)] -> (숫자, 빈도수) 형태
freq = counter.most_common()

# 최빈값이 여러 개인지 확인
# freq[0][1]은 가장 많이 나온 횟수 (첫 번째 원소의 빈도)
# freq[1][1]은 두 번째로 많이 나온 횟수
if len(freq) > 1 and freq[0][1] == freq[1][1]:
    # 최빈값이 여러 개 -> 같은 빈도를 가진 숫자들을 모두 찾기
    max_freq = freq[0][1]  # 최대 빈도수
    mode_list = []  # 최빈값 후보들을 담을 리스트

    for num, count in freq:
        if count == max_freq:
            mode_list.append(num)  # 같은 빈도면 리스트에 추가
        else:
            break  # 빈도가 다르면 중단 (이미 정렬되어 있으니까)

    # mode_list를 정렬한 후 두 번째 값 선택
    # 예: [1, 2] -> 정렬 -> [1, 2] -> mode_list[1] = 2
    mode_list.sort()
    mode = mode_list[1]
else:
    # 최빈값이 하나만 있으면 그냥 그 값 출력
    mode = freq[0][0]  # freq[0]은 (숫자, 빈도수) 튜플 -> [0]으로 숫자만 추출

print(mode)

# --------------------------------
# (4) 범위 구하기 (최댓값 - 최솟값)
# --------------------------------
# 예: [1, 2, 3, 4, 5] -> 5 - 1 = 4
# numbers는 이미 정렬되어 있으므로:
# - numbers[-1]이 최댓값 (맨 끝)
# - numbers[0]이 최솟값 (맨 앞)
range_value = numbers[-1] - numbers[0]
print(range_value)

# ========================================
# 3. Q&A
# ========================================
# Q1: Counter는 왜 사용하나요?
# A: 딕셔너리로 직접 빈도수를 세는 것보다 간편합니다.
#    Counter({1: 2, 2: 3})처럼 자동으로 개수를 세어주고,
#    most_common() 메서드로 빈도순 정렬도 쉽게 할 수 있습니다.
#
# Q2: most_common()의 결과는 어떤 형태인가요?
# A: [(숫자, 빈도수), (숫자, 빈도수), ...] 형태의 리스트입니다.
#    빈도수가 높은 순서대로 정렬되어 있습니다.
#    예: [(2, 3), (1, 2), (3, 1)] -> 2가 3번, 1이 2번, 3이 1번
#
# Q3: 왜 최빈값이 여러 개일 때 두 번째로 작은 값을 출력하나요?
# A: 문제에서 그렇게 요구하기 때문입니다.
#    이는 최빈값이 중복될 때 일관된 출력을 위한 규칙입니다.
#    예: [1, 1, 2, 2] -> 1과 2 모두 최빈값 -> 2 출력
#
# Q4: round() 함수는 어떻게 작동하나요?
# A: 소수점 첫째 자리에서 반올림합니다.
#    예: round(2.5) = 2 (파이썬은 짝수로 반올림하는 "banker's rounding")
#        round(3.5) = 4
#        round(2.7) = 3
#
# Q5: sys.stdin.readline을 왜 사용하나요?
# A: input()보다 훨씬 빠릅니다. N이 최대 500,000이므로
#    시간 초과를 방지하기 위해 사용합니다.
#
# Q6: N // 2로 중앙값을 찾는 이유는?
# A: N은 항상 홀수입니다. 예를 들어:
#    N=5 -> 인덱스 0,1,2,3,4 -> 5//2=2 -> numbers[2]가 중앙값
#    N=7 -> 인덱스 0,1,2,3,4,5,6 -> 7//2=3 -> numbers[3]이 중앙값
#
# Q7: 정렬을 왜 해야 하나요?
# A: 중앙값을 구하려면 반드시 정렬이 필요합니다.
#    또한 범위를 구할 때도 정렬된 리스트에서 첫 값과 마지막 값을
#    빼면 쉽게 구할 수 있습니다.
#
# ========================================
# 학습 포인트
# ========================================
# 1. Counter 사용법: from collections import Counter
# 2. most_common() 메서드로 빈도순 정렬
# 3. 정렬의 중요성: 중앙값, 범위 구하기
# 4. 조건 분기: 최빈값이 여러 개일 때 처리
# 5. 빠른 입력: sys.stdin.readline
